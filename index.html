<!DOCTYPE html>
<!--

  [Please Enter New Password]

  fortnight

  [Error: Password is Two Week]

-->
<html lang="en">
  <head>
    <title>Jezen Thomas | Haskell, Unix, Minimalism, and Entrepreneurship.</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="description" content="Haskell programmer, entrepreneur, co-founder & CTO of Supercede.">
    <meta name="author" content="Jezen Thomas">
    <meta property="og:title" content="Jezen Thomas | Haskell, Unix, Minimalism, and Entrepreneurship.">
    <meta property="og:description" content="Haskell programmer, entrepreneur, co-founder & CTO of Supercede.">
    <meta property="og:type" content="article">
    <meta property="og:image" content="/static/img/prestiz.jpg">
    <meta property="og:site_name" content="Jezen Thomas">
    <meta name="twitter:card" content="summary_large_image">
    <meta property="twitter:domain" content="jezenthomas.com">
    <meta name="twitter:title" content="Jezen Thomas | Haskell, Unix, Minimalism, and Entrepreneurship.">
    <meta name="twitter:description" content="Haskell programmer, entrepreneur, co-founder & CTO of Supercede.">
    <meta name="twitter:image" content="/static/img/prestiz.jpg">
    <meta name="format-detection" content="telephone=no">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/gif" href="/doom.gif">
    <link rel="stylesheet" type="text/css" href="/css/99b1b83f825f17c1eb6396135956f2b2.css">
    <link rel="alternate" type="application/rss+xml" href="/feed.xml" title="RSS feed">
  </head>
  <body>
    <div class="about">

  <a class="portrait" href="/">
    <img alt="Jezen Thomas" src="/static/img/jgt.jpg" loading="lazy">
  </a>

  <h1 class="site-title">
    <a href="/">Jezen Thomas</a>
  </h1>

  <p class="bio">
    CTO &amp; Co-Founder at <a href="https://supercede.com">Supercede</a>.
    Haskell programmer.
    Writing about business and software engineering.
    Working from anywhere.
  </p>

  <nav>
    <ul>
      <li>
        <a aria-current="true" href="/">Home</a>
      </li>
      <li>
        <a href="/posts">Blog</a>
      </li>
      <li>
        <a href="/about">About</a>
      </li>
      <li id="bmac">
        <a href="https://buymeacoffee.com/jezen">Buy me a coffee</a>
      </li>
    </ul>
  </nav>

  <footer>&copy; 2024 Jezen Thomas</footer>

</div>

    <div id="main"><article>
  <h2 class="post-title">
    <a href="/2023/11/stubbing-io-in-yesod/">Stubbing I/O in Yesod</a>
  </h2>
  <div class="post-meta">
    <p class="post-date">
      <span>November  5, 2023</span>
      
      | Kaş, Türkiye
      
    </p>
  </div>
  <p>Here’s the scenario.</p>
<p>You’re writing a web application in Yesod. In one of your request handler
functions, you need to run some IO action. This might be to make an HTTP
request against an online weather service, or this might be to charge someone’s
credit card, or even just to generate some random number.</p>
<p>Taking the latter as an example, imagine we want to generate a random number
and then respond to the user’s request by reporting whether the randomly
generated number is even or odd.</p>
<p>We might write code which looks like this.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Application</span> <span class="kw">where</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Yesod</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">App</span> <span class="ot">=</span> <span class="dt">App</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>/random RandomR GET</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>|]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="ot">getRandomR ::</span> <span class="dt">Handler</span> <span class="dt">Value</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>getRandomR <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> liftIO randomNumber</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  returnJson <span class="op">$</span> isEven n</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="ot">    randomNumber ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    randomNumber <span class="ot">=</span> randomRIO (<span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="ot">    isEven ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    isEven n <span class="ot">=</span> <span class="kw">if</span> <span class="fu">even</span> n <span class="kw">then</span> <span class="st">&quot;even&quot;</span> <span class="kw">else</span> <span class="st">&quot;odd&quot;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></span></code></pre></div>
<p>This is a complete Yesod application. We can run this locally and it will be
listening for requests on port 3000. When we send requests there, we can see
our application dutifully responding with whether or not the randomly generated
number was even or odd.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> curl http://localhost:3000/random</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;even&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> curl http://localhost:3000/random</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;odd&quot;</span></span></code></pre></div>
<p>This is all well and good, but how do we write an automated test for this? We
can’t control the randomness of our pseudo-random number generator. Similarly,
if instead of generating a random number this were an HTTP request to attempt
to charge someone’s credit card with some payment provider, <em>e.g.</em>, Stripe,
then we wouldn’t be able to write a reliable automated test for this because we
don’t control Stripe’s servers.</p>
<p>What we need to do is to <em>stub</em> out this IO action. This means that instead of
running the real implementation during the test, we swap it out for a fake
version that we <em>can</em> control.</p>
<p>One simple approach for this is with <em>dependency injection</em>.</p>
<p>Instead of defining our <code>randomNumber</code> function alongside our request handler,
we can declare it as part of our application’s foundational data type.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">App</span> <span class="ot">=</span> <span class="dt">App</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> appRandomNumber ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>When we initialise our application, we construct our <code>App</code> value with the real
implementation of our function.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> warp <span class="dv">3000</span> <span class="op">$</span> <span class="dt">App</span> randomNumber</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    randomNumber <span class="ot">=</span> <span class="co">-- real implementation</span></span></code></pre></div>
<p>Since our <code>randomNumber</code> function is no longer defined alongside our request
handler, we’ll now need to ask for that function from within the handler
instead.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getRandomR ::</span> <span class="dt">Handler</span> <span class="dt">Value</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>getRandomR <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> liftIO <span class="op">=&lt;&lt;</span> getsYesod appRandomNumber</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  returnJson <span class="op">$</span> isEven n</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    isEven ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    isEven n <span class="ot">=</span> <span class="co">-- …</span></span></code></pre></div>
<p>This behaves exactly as it did before, but now we’re able to swap out our
<code>randomNumber</code> function for a fake version in an automated test with
<code>testModifySite</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withApp ::</span> <span class="dt">SpecWith</span> (<span class="dt">TestApp</span> <span class="dt">App</span>) <span class="ot">-&gt;</span> <span class="dt">Spec</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>withApp <span class="ot">=</span> before <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">App</span> randomNumber, <span class="fu">id</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="ot">stub ::</span> <span class="dt">YesodDispatch</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">YesodExample</span> a ()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>stub f <span class="ot">=</span> testModifySite (\app <span class="ot">-&gt;</span> <span class="fu">pure</span> (f app, <span class="fu">id</span>))</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="ot">spec ::</span> <span class="dt">Spec</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>spec <span class="ot">=</span> withApp <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>  describe <span class="st">&quot;GET /random&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    it <span class="st">&quot;works with even numbers&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>      stub (\a <span class="ot">-&gt;</span> a { appRandomNumber <span class="ot">=</span> <span class="fu">pure</span> <span class="dv">66</span> })</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>      get <span class="dt">RandomR</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>      statusIs <span class="dv">200</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>      bodyEquals <span class="st">&quot;\&quot;even\&quot;&quot;</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    it <span class="st">&quot;works with odd numbers&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>      stub (\a <span class="ot">-&gt;</span> a { appRandomNumber <span class="ot">=</span> <span class="fu">pure</span> <span class="dv">17</span> })</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>      get <span class="dt">RandomR</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>      statusIs <span class="dv">200</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>      bodyEquals <span class="st">&quot;\&quot;odd\&quot;&quot;</span></span></code></pre></div>
<p>Of course, the usual warnings apply. There are problems that come along with
stubbing out functions — if your stub doesn’t accurately reflect what that
function <em>actually</em> does, then your test is only giving you false confidence.</p>
<p>People often say that stubbing is bad and that you shouldn’t do it. I don’t
think this advice is useful. Yes, your tests and application logic should be
pure as far as you can help it. But sometimes you really <em>do</em> need a stub.</p>
<p>A working example of this approach is <a href="https://github.com/jezen/yesod-stubbing-example">available here</a>.</p>

</article>
<article>
  <h2 class="post-title">
    <a href="/2023/08/haskell-pattern-qualified-imports/">Haskell Pattern: Design for Qualified Imports</a>
  </h2>
  <div class="post-meta">
    <p class="post-date">
      <span>August 17, 2023</span>
      
      | Kraków, Poland
      
    </p>
  </div>
  <p>When you’re writing library code, design for qualified imports.</p>
<p>Let’s say we’re writing a module which is concerned with parsing email
addresses. Inside this <code>Email</code> module, a function named <code>parseEmail</code> would be
carrying more context in its name than is necessary. The name <code>parse</code> would be
sufficient.</p>
<p>When applying our parsing function in some <em>other</em> module, the name needs to be
more descriptive so that it is more obvious what kind of thing the parsing
function parses.</p>
<p>We also might need to disambiguate this parsing function from another parsing
function that may be in scope.</p>
<p>✘ <code>Email.parseEmail</code> is redundant.</p>
<p>✘ <code>parseEmail</code> makes it hard to know where the function is defined.</p>
<p>✔ <code>Email.parse</code> is easy to read.</p>
<p>✔ <code>Email.parse</code> makes it clear what kind of thing we’re parsing.</p>
<p>✔ <code>Email.parse</code> makes it clear where that function is defined.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Acme.Email</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">Email</span> <span class="co">-- exports `parse`, not `parseEmail`</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> Email.parse <span class="st">&quot;foo@bar.com&quot;</span></span></code></pre></div>
<p>The module describes the context we’re in. Sometimes we need to make
that context clearer, and sometimes the context is already clear enough.</p>

</article>
<article>
  <h2 class="post-title">
    <a href="/2023/06/yesod-forms-with-newtypes-and-smart-constructors/">Yesod Forms, Newtypes, and Smart Constructors</a>
  </h2>
  <div class="post-meta">
    <p class="post-date">
      <span>June 14, 2023</span>
      
      | Łódź, Poland
      
    </p>
  </div>
  <p>Say we’re writing a web application, and we’re modelling a login form.</p>
<p>If the types in your system are primitive, you don’t need to do much to parse
them from values outside your system boundary, <em>i.e.</em>, those submitted by a
user through a web form.</p>
<p>It’s easy enough to use a <code>textField</code> for each field in our login form.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Assume this type synonym exists for all examples in this article</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Form</span> x <span class="ot">=</span> <span class="dt">Html</span> <span class="ot">-&gt;</span> <span class="dt">MForm</span> (<span class="dt">HandlerFor</span> <span class="dt">App</span>) (<span class="dt">FormResult</span> x, <span class="dt">Widget</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- A login form with a single field</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">LoginForm</span> <span class="ot">=</span> <span class="dt">LoginForm</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> loginFormEmail ::</span> <span class="dt">Text</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="ot">loginForm ::</span> <span class="dt">Form</span> <span class="dt">LoginForm</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>loginForm extra <span class="ot">=</span>  <span class="kw">do</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  email <span class="ot">&lt;-</span> mreq textField <span class="st">&quot;&quot;</span> <span class="dt">Nothing</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">LoginForm</span> <span class="op">&lt;$&gt;</span> <span class="fu">fst</span> email, <span class="op">$</span>(widgetFile <span class="st">&quot;login&quot;</span>))</span></code></pre></div>
<p>No surprises here.</p>
<h2 id="with-newtypes">With Newtypes</h2>
<p>What if our types aren’t exactly <code>Text</code> values, but are some kind of
equivalent type? For example, what if we’re representing our email value with a
newtype which wraps the underlying text value?</p>
<p>In Yesod, a <code>Field</code> cannot be a functor so it’s not obvious how to reuse a
<code>textField</code> and make it produce an <code>Email</code> value instead.</p>
<p>Fortunately, Yesod’s <a href="https://hackage.haskell.org/package/yesod-form">form library</a> provides <a href="https://hackage.haskell.org/package/yesod-form-1.7.4/docs/Yesod-Form-Functions.html#v:convertField"><code>convertField</code></a> to handle
this case. You apply this function to a couple of functions for converting to
and from your newtype, and a form field you wish to wrap.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Email</span> <span class="ot">=</span> <span class="dt">Email</span> {<span class="ot"> unEmail ::</span> <span class="dt">Text</span> }</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">LoginForm</span> <span class="ot">=</span> <span class="dt">LoginForm</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> loginFormEmail ::</span> <span class="dt">Email</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="ot">loginForm ::</span> <span class="dt">Form</span> <span class="dt">LoginForm</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>loginForm extra <span class="ot">=</span>  <span class="kw">do</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  email <span class="ot">&lt;-</span> mreq (convertField <span class="dt">Email</span> unEmail textField) <span class="st">&quot;&quot;</span> <span class="dt">Nothing</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">LoginForm</span> <span class="op">&lt;$&gt;</span> <span class="fu">fst</span> email, <span class="op">$</span>(widgetFile <span class="st">&quot;login&quot;</span>))</span></code></pre></div>
<h2 id="with-smart-constructors">With Smart Constructors</h2>
<p>Newtype wrappers are better than working directly with primitive types, but by
themselves they don’t provide a great deal of type safety because the wrapped
data isn’t any more constrained than when it’s unwrapped.</p>
<p>To solve that, we would reach for a <a href="https://kowainik.github.io/posts/haskell-mini-patterns#smart-constructor">smart constructor</a>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Explicitly exclude the value constructor</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Email</span> (<span class="dt">Email</span>, unEmail, email) <span class="kw">where</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- The newtype wrapper without a record field</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Email</span> <span class="ot">=</span> <span class="dt">Email</span> <span class="dt">Text</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Unwrap the newtype</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">unEmail ::</span> <span class="dt">Email</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>unEmail (<span class="dt">Email</span> email) <span class="ot">=</span> email</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- The smart constructor</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="ot">email ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Email</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>email t</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="st">&quot;@&quot;</span> <span class="ot">`isInfixOf`</span> t <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Email</span> t)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>What if we’re using the smart constructor pattern and our newtypes can’t be
naïvely constructed? We can’t use <code>convertField</code> because the types won’t line
up.</p>
<p>Again, Yesod conveniently provides <a href="https://hackage.haskell.org/package/yesod-form-1.7.4/docs/Yesod-Form-Functions.html#v:checkMMap"><code>checkMMap</code></a> for transforming some
existing field into one that both performs validation <em>and</em> converts the
datatype. This way we can use our smart constructor in the field directly
instead of having to define validation rules in two places.</p>
<p>This function wants to ultimately produce an <code>Either msg b</code> but our smart
constructor only produces a <code>Maybe b</code>. We can use the <a href="https://hackage.haskell.org/package/errors-2.3.0/docs/Control-Error-Util.html#v:note"><code>note</code></a> function to
promote it and provide a friendly error message.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Email</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">LoginForm</span> <span class="ot">=</span> <span class="dt">LoginForm</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> loginFormEmail ::</span> <span class="dt">Email</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="ot">loginForm ::</span> <span class="dt">Form</span> <span class="dt">LoginForm</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>loginForm extra <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  email <span class="ot">&lt;-</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> msg <span class="ot">=</span> asText <span class="st">&quot;Invalid email&quot;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        checkEmail <span class="ot">=</span> <span class="fu">pure</span> <span class="op">.</span> note msg <span class="op">.</span> email</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> mreq (checkMMap checkEmail unEmail textField) <span class="st">&quot;&quot;</span> <span class="dt">Nothing</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dt">LoginForm</span> <span class="op">&lt;$&gt;</span> <span class="fu">fst</span> email, <span class="op">$</span>(widgetFile <span class="st">&quot;login&quot;</span>))</span></code></pre></div>
<p>Since <code>checkMMap</code> runs in the <code>Handler</code> monad, you can also run IO actions or
database transactions as part of the validation step. For example, you could
query the database and check that the email address you’re trying to log in
with actually exists.</p>
<p>If you want a little more assurance, it might be worth writing a property-based
test which asserts that your functions to convert to and from your newtype
successfully <a href="https://hedgehog.qa/article/haskell-round-trip">roundtrip</a>.</p>
<p>Yesod’s form library is actually pretty powerful and satisying. It could
perhaps do with more examples of what good looks like, and hopefully this short
article helps. I’ve found that my code is generally neater when I’m able to
manage parsing/validation together at the web form level.</p>

</article>

</div>

    <script type="text/javascript">
      [].slice.call(document.querySelectorAll('.footnote-ref sup')).forEach(function(el) {
        var content = el.innerText;
        el.innerText = '[' + content + ']';
      })
    </script>
  </body>
</html>
